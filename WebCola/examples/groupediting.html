<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Grouped Layout</title>
    <style>
        @import url(../style.css);
        body {
            width:1200px;
        }
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: move;
        }

        .group {
            stroke: #fff;
            stroke-width: 2.5px;
            cursor: move;
            opacity: 0.7;
        }

        .link {
            stroke: #7a4e4e;
            stroke-width: 3px;
            stroke-opacity: 1;
        }

        .label {
            fill: white;
            font-family: Verdana;
            font-size: 25px;
            text-anchor: middle;
            cursor: move;
        }
        .background {
            fill: white;
        }
    </style>
</head>
<body>
    <div class="header" style="float:none; text-align:center" width="100%">
        <h1>Layout with hierarchical grouping</h1>
    </div>
    <div id="svgarea" style="float:left">
        <script src="../extern/d3.v3.js"></script>
        <script src="../cola.v3.min.js"></script>
        <script>

            Array.prototype.in_array_position = function (e) {
                for (i = 0; i < this.length; i++) {
                    if (this[i] == e)
                        return i;
                }
                return -1;
            }

            Array.prototype.move = function (old_index, new_index) {
                if (new_index >= this.length) {
                    var k = new_index - this.length;
                    while ((k--) + 1) {
                        this.push(undefined);
                    }
                }
                this.splice(new_index, 0, this.splice(old_index, 1)[0]);
                return this;
            };
            /*
            function clone(graph) {
                var temp = {};
                temp.nodes = [];
                temp.links = [];
                temp.groups = [];

                graph.nodes.forEach(function (e) {
                    temp.nodes.push(e);
                });

                graph.links.forEach(function (e) {
                    temp.links.push(e);
                });

                graph.groups.forEach(function (e) {
                    temp.groups.push(e);
                });

                return temp;
            }
            */
            var width = 960,
                height = 800;

            var color = d3.scale.category20();

            function heuristicPowerGraphLayout(graph, size) {
                
                var d3cola = cola.d3adaptor()
                .avoidOverlaps(false)
                .nodes(graph.nodes)
                .links(graph.links)
                .groups(graph.groups);

                var n = graph.nodes.length;
                var edges = [];
                var vs = graph.nodes.slice(0);
                vs.forEach(function (v, i) {
                    return v.index = i;
                });
                graph.groups.forEach(function (g) {
                    var sourceInd = g.gid = g.gid + n;
                    vs.push(g);
                    if (typeof g.leaves !== 'undefined')
                        g.leaves.forEach(function (v) {
                            return edges.push({ source: sourceInd, target: v.index });
                        });
                    if (typeof g.groups !== 'undefined')
                        g.groups.forEach(function (gg) {
                            return edges.push({ source: sourceInd, target: gg.gid + n });
                        });
                });
                

                d3cola = cola.d3adaptor().size(size).nodes(vs).links(edges).avoidOverlaps(false).symmetricDiffLinkLengths(10).start(100);

                d3cola = cola.d3adaptor().size(size).avoidOverlaps(true)
                    .linkDistance(100)
                    .handleDisconnected(false)
                    .nodes(graph.nodes)
                    .links(graph.links)
                    .groups(graph.groups)
                    .start(0, 0, 200);
                    
                return d3cola;
            }
            
            var cola1;
            var outer = d3.select("#svgarea").append("svg")
                            .attr("width", width)
                            .attr("height", height)
                            .attr("pointer-events", "all");

            
            //var svg = d3.select(".svgarea").append("svg")
            //    .attr("width", width)
            //    .attr("height", height);

            
            var checkGroupChange = function (graph) {
                //check and delete empty group
                var tempGraphGroupsLength = graph.groups.length;
                for (var index = tempGraphGroupsLength - 1; index >= 0; index--) {
                    //console.log(graph.groups.length);
                    //console.log(index);

                    if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                        (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                        graph.groups.splice(index, 1);
                    } else {
                        if (typeof graph.groups[index].groups != "undefined") {
                            var grouplength = graph.groups[index].groups.length;
                            for (var i = grouplength - 1; i >= 0; i--) {
                                if ((typeof graph.groups[index].groups[i].leaves == "undefined" || graph.groups[index].groups[i].leaves.length == 0) &&
                                    (typeof graph.groups[index].groups[i].groups == "undefined" || graph.groups[index].groups[i].groups.length == 0)) {
                                    graph.groups[index].groups.splice(i, 1);
                                }
                            }
                        }
                        if ((typeof graph.groups[index].leaves == "undefined" || graph.groups[index].leaves.length == 0) &&
                            (typeof graph.groups[index].groups == "undefined" || graph.groups[index].groups.length == 0)) {
                            graph.groups.splice(index, 1);
                        }
                    }
                }

            }

            //draw all the graph
            var runtimes = 1;
            var drawPicture = function (graph) {
                //console.log(graph);
                if (runtimes == 1) {
                    cola1 = heuristicPowerGraphLayout(graph, [width, height]);
                    runtimes++;
                } else {
                    cola1
                    .nodes(graph.nodes)
                    .links(graph.links)
                    .groups(graph.groups)
                    .start(50, 10, 30)
                }

                //add zoom function
                outer.append('rect')
                .attr('class', 'background')
                .attr('width', "100%")
                .attr('height', "100%")
                .call(d3.behavior.zoom().on("zoom", redraw));
                var vis = outer
                    .append('g')
                    .attr('transform', 'translate(80,-50) scale(0.9)');

                function redraw() {
                    vis.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
                }
                
                var pad = 3;

                var group = vis.selectAll(".group")
                    .data(graph.groups)
                    .enter().append("rect")
                    .attr("rx", 8).attr("ry", 8)
                    .attr("class", "group")
                    .style("fill", function (d, i) { return color(i); });


                var link = vis.selectAll(".link")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("class", "link");


                var node = vis.selectAll(".node")
                    .data(graph.nodes)
                    .enter().append("rect")
                    .attr("class", "node")
                    .attr("width", function (d) { return d.width - 2 * pad; })
                    .attr("height", function (d) { return d.height - 2 * pad; })
                    .attr("rx", 5).attr("ry", 5)
                    .style("fill", function (d) { return color(3); })
                    .call(cola1.drag);

                var label = vis.selectAll(".label")
                    .data(graph.nodes)
                    .enter().append("text")
                    .attr("class", "label")
                    .text(function (d) { return d.name; })
                    .call(cola1.drag);

                var triangledown = vis.selectAll(".triangledown")
                    .data(graph.groups)
                    .enter()
                    .append("path")
                    .attr("class", "triangledown")
		            .attr("d", d3.svg.symbol().type("triangle-down").size(7*7*7))
                    .attr("fill", "blue");

                var triangleup = vis.selectAll(".triangleup")
                    .data([])
                    .enter()
                    .append("path")
                    .attr("class", "triangleup")
		            .attr("d", d3.svg.symbol().type("triangle-up").size(7 * 7 * 7))
                    .attr("fill", "blue");

                node.append("title")
                    .text(function (d) { return d.name; });

                cola1.on("tick", function () {
                    link.attr("x1", function (d) { return d.source.x; })
                        .attr("y1", function (d) { return d.source.y; })
                        .attr("x2", function (d) { return d.target.x; })
                        .attr("y2", function (d) { return d.target.y; });

                    node.attr("x", function (d) { return d.x - d.width / 2 + pad; })
                        .attr("y", function (d) { return d.y - d.height / 2 + pad; });
                    
                    var groupx = -1;
                    var groupy = -1;

                    group.attr("x", function (d) { groupx = d.bounds.x; return d.bounds.x; })
                         .attr("y", function (d) { groupy = d.bounds.y; return d.bounds.y; })
                         .attr("width", function (d) { return d.bounds.width(); })
                         .attr("height", function (d) { return d.bounds.height(); });

                    label.attr("x", function (d) { return d.x; })
                         .attr("y", function (d) {
                             var h = this.getBBox().height;
                             return d.y + h / 4;
                         });
                    triangledown.attr("transform", function (d) {                       
                        return "translate(" + (d.bounds.x + 20) + ", " + (d.bounds.y + 20) + ")";
                    })
                });

                node.on("click", function () {
                    var e = d3.event,
                        isSelected = d3.select(this).classed("selected");
                    if (e.ctrlKey) {
                        d3.select(this).classed("selected", !isSelected);
                        if (!isSelected) {
                            d3.select(this).style("fill", "teal");
                        } else {
                            d3.select(this).style("fill", function (d) { return color(3); });
                        }
                    } else {
                        d3.selectAll(".selected").classed("selected", false);
                        d3.select(this).style("fill", function (d) { return color(3); });
                    }
                });

                label.on("click", function () {
                    var e = d3.event;
                    var currLabelNode = d3.select(this).data();
                    var currLabelRect = d3.select(d3.selectAll(".node")[0][currLabelNode[0].index]);
                    var isSelected = currLabelRect.classed("selected");

                    if (e.ctrlKey) {
                        currLabelRect.classed("selected", !isSelected);
                        if (!isSelected) {
                            currLabelRect.style("fill", "teal");
                        } else {
                            currLabelRect.style("fill", function (d) { return color(3); });
                        }
                    } else {
                        d3.selectAll(".selected").classed("selected", false);
                        currLabelRect.style("fill", function (d) { return color(3); });
                    }

                });

                group.on("click", function (d, i) {
                    var e = d3.event,
                        isSelected = d3.select(this).classed("selectedgroup");

                    if (e.ctrlKey) {
                        d3.select(this).classed("selectedgroup", !isSelected);
                        if (!isSelected) {
                            d3.select(this).style("fill", "teal");
                        } else {
                            d3.select(this).style("fill", function (d) { return color(i); });
                        }

                    } else {

                        d3.selectAll(".selectedgroup").classed("selectedgroup", false);
                        d3.select(this).style("fill", function (d) { return color(i); });

                    }
                });

                var getParent = function (p, currentGroup) {
                    while (typeof p.parent != "undefined") {
                        p = p.parent;
                        if (p == currentGroup) {
                            break;
                        }
                    }
                    return p;
                };

                //var actualGraph = clone(graph);

                triangledown.on("click", function (d, i) {
                    console.log("triangledown");
                    /*
                    var newNode = { "name": "group " + d.gid, "width": 60, "height": 40 };
                    var inGroupNodes = d3.selectAll(".node").data().filter(function (v) {
                        return getParent(v, d) == d;
                    });
                    graph.nodes.push(newNode);
                    graph.links.forEach(function (e, vi) {
                        var source = inGroupNodes.in_array_position(e.source);
                        var target = inGroupNodes.in_array_position(e.target);
                        if (source != -1 && target != -1) {
                            graph.links.splice(vi, 1);
                        } else if (source != -1 && target == -1) {
                            e.source = newNode;
                        } else if (source == -1 && target != -1) {
                            e.target = newNode;
                        }
                    });

                    inGroupNodes.forEach(function (e) {
                        graph.nodes.splice(graph.nodes.in_array_position(e), 1);
                    });

                    //graph.groups.splice(i, 1);

                    //var collapsedGroup = { "leaves": [] };
                    if (typeof graph.groups[i].leaves == "undefined") {
                        graph.groups[i].leaves = [];
                    }
                    graph.groups[i].leaves.push(newNode);
                    //graph.groups.push(collapsedGroup);

                    d3.selectAll("rect").remove();
                    d3.selectAll("line").remove();
                    d3.selectAll("text").remove();
                    drawPicture(graph);
                    //var templength = graph.nodes.length - 1;
                    /*d3.selectAll(".node")
                        .style("stroke-width", 0)
                        .style("opacity", 0);*/
                });

                triangleup.on("click", function (d) {
                    console.log("triangleup");
                });

                //when click on any place of svg clear the class of selected group/node
                outer.on("mousedown", function () {
                    if (!d3.event.ctrlKey) {
                        d3.selectAll(".selected").classed("selected", false).style("fill", function (d) { return color(3); })
                        d3.selectAll(".selectedgroup").classed("selectedgroup", false);
                        group.style("fill", function (d, i) { return color(i); });
                    }
                });

                //drag group 
                var inGroupNodes = [];
                var inGroupNodesLength = 0;
                
                var dragGroup = d3.behavior.drag()
                    .origin(function (d) { return d; })
                    .on("dragstart.d3adaptor", function (d, i) {

                        inGroupNodes = d3.selectAll(".node").data().filter(function (v) {
                            return getParent(v, d) == d;
                        });
                        inGroupNodesLength = inGroupNodes.length;
                        for (var index = 0; index < inGroupNodesLength; index++) {
                            inGroupNodes[index].fixed |= 2;
                            inGroupNodes[index].px = inGroupNodes[index].x;
                            inGroupNodes[index].py = inGroupNodes[index].y;
                        }
                    })
                    .on("drag.d3adaptor", function (d, i) {

                        for (var index = 0; index < inGroupNodesLength; index++) {
                            inGroupNodes[index].px += d3.event.dx;
                            inGroupNodes[index].py += d3.event.dy;
                        }
                        cola1.resume();
                    })
                    .on("dragend.d3adaptor", function (d, i) {
                        for (var index = 0; index < inGroupNodesLength; index++) {
                            inGroupNodes[index].fixed &= ~6;
                        }
                    });
                group.call(dragGroup);

                document.onkeyup = function (e) {
                    if (!e.shiftKey) {
                        node.call(cola1.drag);
                        label.call(cola1.drag);
                        group.call(dragGroup);
                    }
                };

                document.onkeydown = function (e) {
                    var ghost = null;
                    var nodex = -1, nodey = -1;
                    var nodeDropgroup = -1;
                    var shiftDragNode = d3.behavior.drag()
                                    .origin(function (d) { return d; })
                                    .on("dragstart.d3adaptor", function (d) {
                                        ghost = vis.selectAll(".ghost")
                                            .data([d])//need to pass a data set not a single object so need []
                                            .enter().append("rect")
                                            .attr("class", "ghost")
                                            .attr("width", function (d) { return d.width - 2 * pad; })
                                            .attr("height", function (d) { return d.height - 2 * pad; })
                                            .attr("rx", 5).attr("ry", 5)
                                            .style("fill", "green")
                                            .style("opacity", 0.3)
                                            .attr("x", function (d) { return d.x - d.width / 2 + pad; })
                                            .attr("y", function (d) { return d.y - d.height / 2 + pad; });
                                    })
                                    .on("drag.d3adaptor", function (d) {

                                        nodex = d3.event.x - d.width / 2 + pad;
                                        nodey = d3.event.y - d.height / 2 + pad;
                                        ghost.attr("x", function (d) { return nodex; })
                                             .attr("y", function (d) { return nodey; });
                                        if (d3.select(this).classed("node") == true) {
                                            d3.select(this).style("fill", "green");
                                        } else if (d3.select(this).classed("label") == true) {
                                            d3.select(d3.selectAll(".node")[0][d.index]).style("fill", "green");
                                        }
                                        var groupStrokeColor = ["Aqua", "Black", "Blue", "BlueViolet", "Brown",
                                                                  "CadetBlue", "Chartreuse", "Chocolate", "Coral", "Crimson",
                                                                  "DarkBlue", "DarkCyan", "DarkGoldenRod ", "DarkGreen", "DarkOrange",
                                                                  "DarkRed", "DarkSlateBlue", "DodgerBlue", "Fuchsia", "GoldenRod"];

                                        var inOneGroup = false;
                                        graph.groups.forEach(function (e, i) {
                                            if (d3.event.x > e.bounds.x &&
                                                d3.event.x < (e.bounds.x + e.bounds.width()) &&
                                                d3.event.y > e.bounds.y &&
                                                d3.event.y < (e.bounds.y + e.bounds.height())) {
                                                group.style("stroke", function (d, vi) { if (vi == i) { return groupStrokeColor[i]; } });
                                                nodeDropgroup = i;
                                                inOneGroup = true;
                                            }
                                        });

                                        if (!inOneGroup) {
                                            group.style("stroke", "#fff");
                                            nodeDropgroup = -1;
                                        }

                                    })
                                    .on("dragend.d3adaptor", function (d) {
                                        d.fixed |= 4;
                                        ghost.remove();
                                        d.x = d.px = nodex;
                                        d.y = d.py = nodey;

                                        //if drag label, link the label to the node
                                        if (d3.select(this).classed("node") == true) {
                                            d3.select(this).style("fill", function (d) { return color(3); });
                                        } else if (d3.select(this).classed("label") == true) {
                                            d3.select(d3.selectAll(".node")[0][d.index]).style("fill", function (d) { return color(3); });
                                        }

                                        //delete the same node index in other group
                                        //traverse each group of allGroup
                                        var deleteSameNode = function (allGroup, currNode) {
                                            allGroup.forEach(function (e, i) {
                                                if (typeof e.leaves != "undefined") {
                                                    var inArrayPosition = e.leaves.in_array_position(currNode);
                                                    if (inArrayPosition != -1) {
                                                        e.leaves.splice(inArrayPosition, 1);
                                                    }
                                                }
                                            });
                                        }

                                        var groupChanged = false;
                                        graph.groups.forEach(function (e, i) {
                                            if (nodeDropgroup == i) {
                                                deleteSameNode(graph.groups, d);
                                                if (typeof e.leaves == "undefined") {
                                                    e.leaves = [];//add attribute "leaves"
                                                }
                                                e.leaves.push(d);
                                                groupChanged = true;
                                            } else if (nodeDropgroup == -1) {

                                                //when nodeDropgroup == -1, group may be changed or not be changed
                                                if (typeof d.parent != "undefined" && d.parent == e) {
                                                    e.leaves.splice(e.leaves.in_array_position(d), 1);
                                                    delete d.parent;//clear parent attribute.
                                                    groupChanged = true;
                                                }
                                            }
                                        });

                                        if (groupChanged) {
                                            checkGroupChange(graph);
                                        }

                                        //must wait till the layout is done. If do not want to wait, how?
                                        cola1.on("end", function () {
                                            node.each(function (d) {
                                                d.fixed &= ~4;
                                            });
                                            cola1.on("end", null);
                                        });

                                        if (groupChanged) {
                                            d3.selectAll("rect").remove();
                                            d3.selectAll("line").remove();
                                            d3.selectAll("text").remove();
                                            drawPicture(graph);
                                        } else {
                                            cola1.start();
                                        }

                                    });

                    var groupGhost = null;
                    var groupx = -1, groupy = -1;
                    var groupDropgroup = -1;
                    var shiftDragGroup = d3.behavior.drag()
                                      .on("dragstart.d3adaptor", function (d) {
                                          groupGhost = vis.selectAll(".ghostgroup")
                                            .data([d])
                                            .enter().append("rect")
                                            .attr("class", "ghostgroup")
                                            .attr("width", function (d) { return d.bounds.width(); })
                                            .attr("height", function (d) { return d.bounds.height(); })
                                            .attr("rx", 8).attr("ry", 8)
                                            .style("fill", "green")
                                            .style("opacity", 0.3)
                                            .attr("x", function (d) { return d.bounds.x; })
                                            .attr("y", function (d) { return d.bounds.y; });
                                          groupx = d.bounds.x;
                                          groupy = d.bounds.y
                                      })
                                      .on("drag.d3adaptor", function (d) {
                                          groupx += d3.event.dx;
                                          groupy += d3.event.dy;
                                          groupGhost.attr("x", function (d) { return groupx; })
                                                    .attr("y", function (d) { return groupy; });

                                          d3.select(this).style("fill", "green");
                                          var groupStrokeColor = ["Aqua", "Black", "Blue", "BlueViolet", "Brown",
                                                                  "CadetBlue", "Chartreuse", "Chocolate", "Coral", "Crimson",
                                                                  "DarkBlue", "DarkCyan", "DarkGoldenRod ", "DarkGreen", "DarkOrange",
                                                                  "DarkRed", "DarkSlateBlue", "DodgerBlue", "Fuchsia", "GoldenRod" ];

                                          var inOneGroup = false;
                                          dragGroupSecondCox = groupx + d.bounds.width() / 2;
                                          graph.groups.forEach(function (e, i) {
                                              
                                              if (e != d && getParent(e, d) != d) {
                                                  if ((Math.abs((groupx + d.bounds.width() / 2) - (e.bounds.x + e.bounds.width() / 2)) < (d.bounds.width() + e.bounds.width()) / 2) &&
                                                      (Math.abs((groupy + d.bounds.height() / 2) - (e.bounds.y + e.bounds.height() / 2)) < (d.bounds.height() + e.bounds.height()) / 2)) {
                                                      group.style("stroke", function (d, vi) { if (vi == i) { return groupStrokeColor[i]; } });
                                                      groupDropgroup = i;
                                                      inOneGroup = true;
                                                  }
                                              }

                                          });

                                          if (!inOneGroup) {
                                              group.style("stroke", "#fff");
                                              groupDropgroup = -1;
                                          }
                                      })
                                      .on("dragend.d3adaptor", function (d) {
                                          //select all the nodes in current group
                                          var inGroupNodes = d3.selectAll(".node").data().filter(function (v) {
                                              return getParent(v, d) == d;
                                          });

                                          //give selected nodes new coordinates.
                                          inGroupNodes.forEach(function (e) {
                                              e.fixed |= 4;
                                              e.x = e.px = (e.x + groupx - d.bounds.x);
                                              e.y = e.py = (e.y + groupy - d.bounds.y);
                                          })

                                          groupGhost.remove();
                                          d3.select(this).style("fill", function (d, i) { return color(d.gid); });

                                          //delete the same group index in other groups
                                          //traverse each group of allGroup
                                          var deleteSameGroup = function (allGroup, currGroup) {
                                              allGroup.forEach(function (e, i) {
                                                  if (typeof e.groups != "undefined") {
                                                      var inArrayPosition = e.groups.in_array_position(currGroup);
                                                      if (inArrayPosition != -1) {
                                                          e.groups.splice(inArrayPosition, 1);
                                                      }
                                                  }
                                              });
                                          }

                                          var groupChanged = false;

                                          graph.groups.forEach(function (e, i) {
                                              if (groupDropgroup == i) {
                                                  deleteSameGroup(graph.groups, d);
                                                  if (typeof e.groups == "undefined") {
                                                      e.groups = [];
                                                  }
                                                  e.groups.push(d);
                                                  
                                                  if (e.gid > d.gid) {
                                                      var temp = -1;
                                                      if (typeof e.groups != "undefined" && e.groups.length != 0) {
                                                          var tempGroupGids = [];
                                                          e.groups.forEach(function (e) {
                                                              tempGroupGids.push(e.gid);
                                                          });
                                                          temp = Math.max.apply(Math, tempGroupGids);
                                                      } else {
                                                          temp = e.gid;
                                                      }

                                                      function moveAllChildGroup(tempGroup) {
                                                          if (typeof tempGroup.groups != "undefined" && tempGroup.groups.length != 0) {
                                                              for (var index = tempGroup.groups.length - 1; index >= 0; index--) {
                                                                  graph.groups.move(d.gid, e.gid);
                                                                  moveAllChildGroup(tempGroup.groups[index]);
                                                              }
                                                          } else {
                                                              graph.groups.move(d.gid, e.gid);
                                                          }
                                                      };

                                                      //If e.gid bigger than d.gid, e will be draw before g, which may cover g.
                                                      //So, g must change place with e.
                                                      if (typeof d.groups != "undefined" && d.groups.length != 0) {
                                                          //graph.groups.move(d.gid, e.gid);
                                                          /*for (var index = d.groups.length; index >= 0; index--) {
                                                              graph.groups.move(d.gid, e.gid);
                                                          }*/
                                                          moveAllChildGroup(d);
                                                      } else {
                                                          graph.groups.move(d.gid, e.gid);
                                                      }
                                                  } else {
                                                      graph.groups.move(d.gid, e.gid + 1);
                                                  }
                                                  groupChanged = true;
                                              } else if (groupDropgroup == -1) {
                                                  if (typeof d.parent != "undefined" && d.parent == e) {
                                                      e.groups.splice(e.groups.in_array_position(d), 1);
                                                      delete d.parent;
                                                      groupChanged = true;
                                                  }
                                              }
                                          });

                                          if (groupChanged) {
                                              checkGroupChange(graph);
                                          }

                                          cola1.on("end", function () {
                                              console.log("layout is done!");
                                              node.each(function (d) {
                                                  d.fixed &= ~4;
                                              });
                                              cola1.on("end", null);
                                          });
                                          console.log("=====graph=====");
                                          console.log(graph);
                                          if (groupChanged) {
                                              d3.selectAll("rect").remove();
                                              d3.selectAll("line").remove();
                                              d3.selectAll("text").remove();
                                              drawPicture(graph);
                                          } else {
                                              cola1.start();
                                          }

                                      });

                    if (e.shiftKey) {

                        label.call(function () {
                            this.call(shiftDragNode);
                        });

                        node.call(function () {
                            this.call(shiftDragNode);
                        });

                        //drag group
                        group.call(function () {
                            this.call(shiftDragGroup);
                        });
                    }
                };
            };

            //d3.json("mytest/smallgrouped.json", function (error, graph) {
            d3.json("graphdata/groupeditinged.json", function (error, graph) {
                drawPicture(graph);

                //add a new node
                d3.selectAll(".addnode")
                        .on("click", function () {
                            var newnodename = "NaN";
                            var frominput = document.getElementById("addnodename").value;

                            if (frominput.trim() != "") {
                                newnodename = frominput.trim();
                            }

                            var newnode1 = { "name": newnodename, "width": 60, "height": 40 };
                            graph.nodes.push(newnode1);

                            d3.selectAll("rect").remove();
                            d3.selectAll("line").remove();
                            d3.selectAll("text").remove();

                            drawPicture(graph);
                        });

                //add selected node/group into a new group
                d3.selectAll(".addgroup")
                        .on("click", function () {
                            var selectedGroups = d3.selectAll(".selectedgroup").data();
                            var selectedNodes = d3.selectAll(".selected").data();
                            var newgroup = { "leaves": [], "groups": [] };

                            //delete the same group index in other groups
                            //traverse each group of allGroup
                            var deleteSameGroup = function (allGroup, currGroup) {
                                allGroup.forEach(function (e, i) {
                                    if (typeof e.groups != "undefined") {
                                        var inArrayPosition = e.groups.in_array_position(currGroup);
                                        if (inArrayPosition != -1) {
                                            e.groups.splice(inArrayPosition, 1);
                                        }
                                    }
                                });
                            }

                            //delete the same node index in other group
                            //traverse each group of allGroup
                            var deleteSameNode = function (allGroup, currNode) {
                                allGroup.forEach(function (e, i) {
                                    if (typeof e.leaves != "undefined") {
                                        var inArrayPosition = e.leaves.in_array_position(currNode);
                                        if (inArrayPosition != -1) {
                                            e.leaves.splice(inArrayPosition, 1);
                                        }
                                    }
                                });
                            }

                            //check whether all the selected group have same parent
                            var sameParentForGroup = false;
                            if (selectedGroups.length != 0) {
                                sameParentForGroup = true;
                                selectedGroups.forEach(function (e) {
                                    if (typeof selectedGroups[0].parent == "undefined" ||
                                        selectedGroups[0].parent != e.parent) {
                                        sameParentForGroup = false;
                                    }
                                });
                            }
                            //check whether all the selected node have same parent
                            var sameParentForNode = false;
                            if (selectedNodes.length != 0) {
                                sameParentForNode = true;
                                selectedNodes.forEach(function (e) {
                                    if (typeof selectedNodes[0].parent == "undefined" ||
                                        selectedNodes[0].parent != e.parent) {
                                        sameParentForNode = false;
                                    }
                                });
                            }


                            if (sameParentForGroup && sameParentForNode &&
                                selectedNodes[0].parent == selectedGroups[0].parent) {

                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });
                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                if (typeof selectedGroups[0].parent.groups == "undefined") {
                                    selectedGroups[0].parent.groups = [];
                                }
                                selectedGroups[0].parent.groups.push(newgroup);
                                graph.groups.splice(selectedGroups[0].parent.gid + 1, 0, newgroup);
                            } else if (sameParentForGroup && !sameParentForNode &&
                                selectedNodes.length == 0) {

                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });
                                if (typeof selectedGroups[0].parent.groups == "undefined") {
                                    selectedGroups[0].parent.groups = [];
                                }
                                //update reference of parent group
                                selectedGroups[0].parent.groups.push(newgroup);
                                //insert newgroup after parent group
                                graph.groups.splice(selectedGroups[0].parent.gid + 1, 0, newgroup);

                            } else if (!sameParentForGroup && sameParentForNode &&
                                selectedGroups.length == 0) {

                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                if (typeof selectedNodes[0].parent.groups == "undefined") {
                                    selectedNodes[0].parent.groups = [];
                                }
                                //update reference of parent group
                                selectedNodes[0].parent.groups.push(newgroup);
                                //insert newgroup after parent group
                                graph.groups.splice(selectedNodes[0].parent.gid + 1, 0, newgroup);
                            } else {

                                //add selected groups into newgroup.groups and delete same group index in other groups
                                selectedGroups.forEach(function (e) {
                                    newgroup.groups.push(e);
                                    deleteSameGroup(graph.groups, e);
                                });

                                //add selected nodes into newgroup.leaves and delete same node index in other groups
                                selectedNodes.forEach(function (e) {
                                    newgroup.leaves.push(e);
                                    deleteSameNode(graph.groups, e);
                                });
                                var newgroupGids = [];//decide insert location
                                newgroup.groups.forEach(function (e) {
                                    newgroupGids.push(e.gid);
                                });
                                //if newgroupGids is empty insertLocation is infinity.
                                var insertLocation = Math.min.apply(Math, newgroupGids);
                                graph.groups.splice(insertLocation, 0, newgroup);
                            }
                            //check group changed or not
                            checkGroupChange(graph);
                            
                            d3.selectAll("rect").remove();
                            d3.selectAll("line").remove();
                            d3.selectAll("text").remove();
                            drawPicture(graph);
                        });

            });

        </script>
    </div>
    <div class="grapharea" style="float:right">
        <br/>
        <br/>
        <br/>
        <br/>
        <br/>
        input node name: <br /><input type="text" style="width:150px" id="addnodename" /><br />
        <input type="button" value="add node" style="width:157px" class="addnode" onclick="javascript:void(0)" />
        <br />
        <input type="button" value="add group" style="width:157px" class="addgroup" onclick="javascript:void(0)" />
    </div>
    <div class="description" style="float:left">
        <p>
            This graph can be edited.<br/>
            1. Input a name, then click addnode button to click a new node. If nothing input, a new node is named NaN.<br />
            2. Press Shift key and click on a node or group. Then this node/group can be dragged into/out a group.<br />
            3. Press Ctrl key and select nodes/groups. Then click addgroup button. A new group will be created which contains the nodes/groups selected before.<br />
        </p>
    </div>
</body>
</html>
